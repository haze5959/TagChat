// Generated by CoffeeScript 1.6.3
(function() {
  var assert, assertHasPromiseApi, assertIsPromise, deferred, expectedMethods, _,
    __slice = [].slice;

  deferred = require('./deferred');

  assert = require('assert');

  _ = require('underscore');

  expectedMethods = ['done', 'fail', 'progress', 'always', 'state', 'then', 'pipe'];

  assertHasPromiseApi = function(promise) {
    var method, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = expectedMethods.length; _i < _len; _i++) {
      method = expectedMethods[_i];
      _results.push(assert(_.has(promise, method)));
    }
    return _results;
  };

  assertIsPromise = function(promise) {
    return assertHasPromiseApi(promise);
  };

  describe('deferred', function() {
    it('should create and return a deferred object', function() {
      var def;
      def = new deferred.Deferred();
      return assert.equal(def.state(), "pending");
    });
    it('should maintain a resolved state', function() {
      var def;
      def = new deferred.Deferred();
      assert.equal(def.state(), "pending");
      def.resolve();
      assert.equal(def.state(), "resolved");
      def.resolve();
      assert.equal(def.state(), "resolved");
      def.reject();
      return assert.equal(def.state(), "resolved");
    });
    it('should maintain a rejected state', function() {
      var def;
      def = new deferred.Deferred();
      assert.equal(def.state(), "pending");
      def.reject();
      assert.equal(def.state(), "rejected");
      def.reject();
      assert.equal(def.state(), "rejected");
      def.resolve();
      return assert.equal(def.state(), "rejected");
    });
    it('should maintain a pending state', function() {
      var def;
      def = new deferred.Deferred();
      assert.equal(def.state(), "pending");
      def.notify();
      return assert.equal(def.state(), "pending");
    });
    it('should call all the done callbacks', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.done(callback).done([callback, callback]);
      def.resolve();
      def.done(callback, callback);
      def.reject();
      def.done(callback, [callback, callback]);
      return def.fail(callback, callback);
    });
    it('should scope done callbacks when using resolveWith', function(done) {
      var callback, def, finish, finishHolder;
      callback = _.after(2, done);
      def = new deferred.Deferred();
      finishHolder = {
        finisher: callback
      };
      finish = function(arg1) {
        assert.equal(42, arg1);
        return this.finisher();
      };
      def.done(finish);
      def.always(function() {
        return callback();
      });
      def.resolveWith(finishHolder, [42]);
      return assert.equal(def.state(), 'resolved');
    });
    it('should return a deferred for empty calls', function() {
      return assertIsPromise(new deferred.Deferred().resolveWith());
    });
    it('should not mangle arrays', function() {
      var def;
      def = new deferred.Deferred();
      def.promise().done(function(arg1, arg2) {
        assert.equal(arg1, 1);
        return assert.equal(arg2, 2);
      });
      return def.resolveWith(def, [1, 2]);
    });
    it('should scope fail callbacks when using rejectWith', function(done) {
      var callback, def, finish, finishHolder;
      callback = _.after(2, done);
      def = new deferred.Deferred();
      finishHolder = {
        finisher: callback
      };
      finish = function(arg1) {
        assert.equal(42, arg1);
        return this.finisher();
      };
      def.fail(finish);
      def.always(function() {
        return callback();
      });
      def.rejectWith(finishHolder, [42]);
      return assert.equal(def.state(), 'rejected');
    });
    it('should call all the fail callbacks', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.fail(callback).fail([callback, callback]);
      def.reject();
      def.fail(callback, callback);
      def.resolve();
      def.fail(callback, [callback, callback]);
      return def.done(callback);
    });
    it('should scope progress callbacks when using notifyWith', function(done) {
      var callback, def, finish, finishHolder;
      callback = _.after(2, done);
      def = new deferred.Deferred();
      finishHolder = {
        finisher: callback
      };
      finish = function(arg1) {
        assert.equal(42, arg1);
        return this.finisher();
      };
      def.progress(finish);
      def.progress(function() {
        return callback();
      });
      def.notifyWith(finishHolder, [42]);
      return assert.equal(def.state(), 'pending');
    });
    it('should call all the progress callbacks each notification', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(9, done);
      def.progress(callback).progress([callback, callback]);
      def.notify();
      def.progress(callback).progress([callback, callback]);
      return def.notify();
    });
    it('should call progress callbacks with updated arguments on each notification', function(done) {
      var callback, def, i;
      def = new deferred.Deferred();
      i = 0;
      callback = function(arg1) {
        assert.equal(arg1, i);
        if (arg1 === 2) {
          return done();
        }
      };
      def.progress(callback);
      def.notify(i);
      i++;
      def.notify(i);
      i++;
      return def.notify(i);
    });
    it('should run notify callbacks and then accept resolution', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(2, done);
      def.progress(callback);
      def.notify();
      assert.equal(def.state(), 'pending');
      def.done(callback);
      return def.resolve();
    });
    it('should run notify callbacks and then accept rejection', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(2, done);
      def.progress(callback);
      def.notify();
      assert.equal(def.state(), 'pending');
      def.fail(callback);
      return def.reject();
    });
    it('should not run notify callbacks after being resolved', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(2, done);
      def.progress(callback);
      def.notify();
      def.done(callback);
      def.resolve();
      return def.notify();
    });
    it('should run additional progress callbacks imediately after being resolved', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(3, done);
      def.progress(callback);
      def.notify();
      def.done(callback);
      def.resolve();
      assert.equal(def.state(), 'resolved');
      return def.progress(callback);
    });
    it('should run additional progress callbacks imediately after being rejected', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(3, done);
      def.progress(callback);
      def.notify();
      def.fail(callback);
      def.reject();
      assert.equal(def.state(), 'rejected');
      return def.progress(callback);
    });
    it('should run additional progress callbacks with the last sent notify arguments', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(3, function(arg1) {
        if (arg1 === 2) {
          return done();
        }
      });
      def.progress(callback);
      def.notify(1);
      def.notify(2);
      def.resolve(5);
      return def.progress(callback);
    });
    it('should call all the always callbacks on resolution', function(done) {
      var callback, def;
      def = new deferred.Deferred();
      callback = _.after(8, done);
      def.always(callback).always([callback, callback]);
      def.resolve();
      def.always(callback, callback);
      def.always(callback, [callback, callback]);
      return def.fail(callback);
    });
    it('should call the always callbacks on rejection', function(done) {
      var def;
      def = new deferred.Deferred();
      def.always(done);
      def.reject();
      return def.done(done);
    });
    it('should call callbacks with arguments', function(done) {
      var callback, finish;
      finish = _.after(8, done);
      callback = function(arg1, arg2) {
        if (arg1 === 42 && arg2 === 24) {
          return finish();
        }
      };
      new deferred.Deferred().always(callback).resolve(42, 24).always(callback);
      new deferred.Deferred().always(callback).reject(42, 24).always(callback);
      new deferred.Deferred().done(callback).resolve(42, 24).done(callback);
      return new deferred.Deferred().fail(callback).reject(42, 24).fail(callback);
    });
    it('should provide a when method', function(done) {
      var all, callback, def1, def2, def3;
      callback = _.after(4, function() {
        return done();
      });
      def1 = new deferred.Deferred().done(callback);
      def2 = new deferred.Deferred().done(callback);
      def3 = new deferred.Deferred().done(callback);
      all = deferred.when(def1, def2, def3).done(callback);
      def1.resolve();
      def2.resolve();
      return def3.resolve();
    });
    describe('pipe', function() {
      it('should pipe on resolution', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 10) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(function(value) {
          return value * 2;
        });
        def.resolve(5);
        return filtered.done(finisher);
      });
      it('should pipe on rejection', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 6) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, function(value) {
          return value * 3;
        });
        def.reject(2);
        return filtered.fail(finisher);
      });
      it('should pipe on progress', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 6) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, null, function(value) {
          return value * 3;
        });
        filtered.progress(finisher);
        return def.notify(2);
      });
      it('should pipe with arrays intact', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value.length === [1, 2, 3].length) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, function(value) {
          value.push(3);
          return value;
        });
        def.reject([1, 2]);
        return filtered.fail(finisher);
      });
      it('should pass through for null filters for done', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 5) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, null);
        def.resolve(5);
        return filtered.done(finisher);
      });
      it('should pass through for null filters for fail', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 5) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, null);
        def.reject(5);
        return filtered.fail(finisher);
      });
      it('should pass through for null filters for notify', function(done) {
        var def, filtered, finisher;
        finisher = function(value) {
          if (value === 5) {
            return done();
          }
        };
        def = new deferred.Deferred();
        filtered = def.pipe(null, null, null);
        filtered.progress(finisher);
        return def.notify(5);
      });
      it('should accept promises from filters and call them later with arguments', function(done) {
        var def, filter;
        def = deferred.Deferred();
        filter = function(result) {
          var def2;
          assert.equal(result, 'r1');
          def2 = deferred.Deferred();
          setTimeout((function() {
            return def2.resolve('r2');
          }), 100);
          return def2;
        };
        def.then(filter).done(function(result) {
          assert.equal(result, 'r2');
          if (result === 'r2') {
            return done();
          }
        });
        return def.resolve('r1');
      });
      return it('should allow changing the state', function(done) {
        var def;
        def = deferred.Deferred();
        def.pipe(function(result) {
          return deferred.Deferred().reject('failure').promise();
        }).fail(function(msg) {
          assert.equal(msg, 'failure');
          if (msg === 'failure') {
            return done();
          }
        });
        return def.resolve('r1');
      });
    });
    describe('then', function() {
      return it('should alias pipe', function() {
        var def;
        def = new deferred.Deferred();
        return assert.equal(def.then, def.pipe);
      });
    });
    describe('promises', function() {
      it('should provide a promise that has a restricted API', function(done) {
        var callback, def, promise;
        def = new deferred.Deferred();
        promise = def.promise();
        assertIsPromise(promise);
        callback = _.after(7, done);
        promise.always(callback).always(callback).progress(callback).fail(callback).done(callback).fail(callback);
        assertIsPromise(promise.progress(callback));
        assertIsPromise(promise.done(callback));
        assertIsPromise(promise.fail(callback));
        assertIsPromise(promise.always(callback));
        assert.equal("pending", promise.state());
        def.notify();
        assert.equal("pending", promise.state());
        def.resolve();
        return assert.equal("resolved", promise.state());
      });
      it('should create a promise out of a given object', function() {
        var candidate, def, promise;
        candidate = {
          id: 42
        };
        def = new deferred.Deferred();
        promise = def.promise(candidate);
        assert.equal(candidate, promise);
        return assertHasPromiseApi(candidate);
      });
      it('should soak up extraneous promises', function() {
        var def, promise;
        def = new deferred.Deferred();
        promise = def.promise().promise();
        assertIsPromise(promise);
        promise.done(function(arg) {
          return assert.equal(arg, 42);
        });
        return def.resolve(42);
      });
      return describe('when', function() {
        it('should return a promise', function() {
          return assertIsPromise(deferred.when(new deferred.Deferred()));
        });
        it('should resolve when all deps have succeeded', function() {
          var after_all, d1, d2;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          after_all = deferred.when(d1, d2);
          d1.resolve();
          assert.equal(after_all.state(), 'pending');
          d2.resolve();
          return assert.equal(after_all.state(), 'resolved');
        });
        it('should reject when there are some failures', function() {
          var after_all, d1, d2;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          after_all = deferred.when(d1, d2);
          d1.resolve();
          assert.equal(after_all.state(), 'pending');
          d2.reject();
          return assert.equal(after_all.state(), 'rejected');
        });
        it('should pass on reject arguments', function(done) {
          var after_all, d1, d2;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          after_all = deferred.when(d1, d2);
          after_all.fail(function(arg1) {
            if (arg1 === 42) {
              return done();
            }
          });
          d1.resolve();
          return d2.reject(42);
        });
        it('should pass on resolve arguments as is when used with a single deferred', function(done) {
          var after_all, d1;
          d1 = new deferred.Deferred();
          after_all = deferred.when(d1);
          assert.equal(d1, after_all);
          after_all.done(function(arg1) {
            if (arg1 === 42) {
              return done();
            }
          });
          return d1.resolve(42);
        });
        it('should special case single or no arguments when using multiple deferreds', function(done) {
          var after_all, d1, d2, d3;
          d1 = new deferred.Deferred();
          d2 = new deferred.Deferred();
          d3 = new deferred.Deferred();
          after_all = deferred.when(d1, d2, d3);
          after_all.done(function(arg1, arg2, arg3) {
            assert.equal(arg1, 42);
            assert.equal(arg2, void 0);
            assert.deepEqual(arg3, ['abc', 123]);
            return done();
          });
          d2.resolve();
          d3.resolve('abc', 123);
          return d1.resolve(42);
        });
        it('should handle non promise arguments', function() {
          return deferred.when(1, 2, 42).done(function(arg1, arg2, arg3) {
            assert.equal(arg1, 1);
            assert.equal(arg2, 2);
            return assert.equal(arg3, 42);
          });
        });
        return it('should handle zero arguments', function(done) {
          return deferred.when().done(done);
        });
      });
    });
    return describe('installation into a jQuery compatible library', function() {
      var exampleArgs;
      exampleArgs = [42, 24];
      it('should install .Deferred', function() {
        var zepto;
        zepto = {};
        deferred.installInto(zepto);
        return assertHasPromiseApi(zepto.Deferred());
      });
      it('should install .when', function() {
        var zepto;
        zepto = {};
        deferred.installInto(zepto);
        return assert.equal(zepto.when.toString(), deferred.when.toString());
      });
      it('should wrap .ajax()', function(done) {
        var zepto;
        zepto = {};
        zepto.ajax = function(options) {
          return done();
        };
        deferred.installInto(zepto);
        return assertIsPromise(zepto.ajax());
      });
      it('should resolve on success', function(done) {
        var callback, promise, success, zepto;
        callback = _.after(3, done);
        zepto = {};
        zepto.ajax = function(options) {
          return options.success.apply(options, exampleArgs);
        };
        deferred.installInto(zepto);
        success = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (args.length === exampleArgs.length) {
            return callback();
          }
        };
        promise = zepto.ajax({
          success: success
        });
        promise.done(success);
        promise.always(success);
        return promise.fail(function() {
          return fail();
        });
      });
      it('should provide an abort mechanism', function(done) {
        var promise, zepto;
        zepto = {};
        zepto.ajax = function(options) {
          return {
            abort: function() {
              return done();
            }
          };
        };
        deferred.installInto(zepto);
        promise = zepto.ajax();
        return promise.abort();
      });
      it('should reject on failure', function(done) {
        var callback, error, promise, zepto;
        callback = _.after(3, done);
        zepto = {};
        zepto.ajax = function(options) {
          return options.error.apply(options, exampleArgs);
        };
        deferred.installInto(zepto);
        error = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (args.length === exampleArgs.length) {
            return callback();
          }
        };
        promise = zepto.ajax({
          error: error
        });
        promise.fail(error);
        promise.always(error);
        return promise.done(function() {
          return fail();
        });
      });
      return it('should work when no ajax callbacks are provided', function(done) {
        var zepto;
        zepto = {};
        zepto.ajax = function(options) {
          return options.success();
        };
        deferred.installInto(zepto);
        return zepto.ajax({
          success: null
        }).done(done);
      });
    });
  });

}).call(this);
